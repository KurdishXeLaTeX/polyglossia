\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{polyglossia}[2019/04/04 v1.44
  Alternative to Babel for XeLaTeX and LuaLaTeX]
\RequirePackage{etoolbox}
\RequirePackage{makecmds}
\RequirePackage{xkeyval}[2008/08/13]
% Will raise error if used with anything else than XeTeX or LuaTeX
\RequirePackage{fontspec}[2010/06/08]% v2.0
% Ironically, ifluatex.sty is included by some other package if we run
% LuaTeX, but it's not if we run XeTeX, and we need it to know which of
% the two engines it is!  Hence we include it here.
\RequirePackage{ifluatex}
% For symmetry with ifluatex
\RequirePackage{ifxetex}
\RequirePackage{expl3}
\RequirePackage{l3keys2e}

% fontspec now uses LaTeX3 packages such as expl3, so we need this:
\ExplSyntaxOn

%% This is for compatibility with Babel-aware package:
\cslet{ver@babel.sty}{\@empty} % this "fakes" babel
\def\languageshorthands#1{\relax} %this is for scrlttr2 class
\AtEndPreamble{\let\bbl@set@language\xpg@set@language} %for biblatex
\AtEndPreamble{\let\bbl@main@language\xpg@main@language} %for biblatex

\ifluatex
  \RequirePackage{luatexbase} % already included by fontspec, but needed here
  \RequireLuaModule{polyglossia}
\fi

% Which version of XeTeX do we use? What is the boudary class? 4095 or 255
\@ifundefined{e@alloc@intercharclass@top}
  {\chardef\xpg@boundaryclass=\@cclv}
  {\let\xpg@boundaryclass=\e@alloc@intercharclass@top}

% Useful for getting list of loaded languages and variants. Like babel's bbl@loaded
\let\xpg@loaded\@empty
\let\xpg@vloaded\@empty

% counter in latin
\let\latin@alph\@alph
\let\latin@Alph\@Alph
\def\latinalph#1{\expandafter\latin@alph\csname c@#1\endcsname}
\def\latinAlph#1{\expandafter\latin@Alph\csname c@#1\endcsname}


%% custom message macros
\providecommand*{\xpg@error}[1]{%
   \PackageError{polyglossia}{#1}{}%
}

\providecommand*{\xpg@warning}[1]{%
   \PackageWarning{polyglossia}{#1}%
}

\providecommand*{\xpg@info}[1]{%
   \PackageInfo{polyglossia}%
   {#1\@gobble}%
} %% the \@gobble is to prevent displaying the line nr

%TODO change all instances of \xpg@nopatterns in gloss-*.ldf files
\providecommand*{\xpg@nopatterns@fallback}[2][nohyphenation]{%
   \xpg@warning{No~ hyphenation~ patterns~ were~ loaded~ for~ `#2'\MessageBreak
         I~ will~ use~ \string\language=\string\l@ #1\space instead}%
   \expandafter\adddialect\csname l@#2\expandafter\endcsname\csname l@#1\endcsname\relax}

\providecommand*{\xpg@nopatterns}[1]{%
   \xpg@warning{No~ hyphenation~ patterns~ were~ loaded~ for~ `#1'\MessageBreak
         I~ will~ use~ \string\language=\string\l@nohyphenation\space instead}%
   %%TODO? \expandafter\adddialect\csname l@#1\endcsname\l@nohyphenation\relax
   }

\def\xpg@ill@value#1#2{%
  \xpg@warning{Illegal~ value~ (#1)~ for~ #2}}

%% use macro if defined, else warn that it is not
\def\csuse@warn#1{%
   \ifcsundef{#1}{\xpg@warning{ \expandafter\string\csname #1\endcsname\space is~ not~ defined}}%
   {\csname #1\endcsname}}

%% ensure directionality if bidi is loaded, else ignore
\def\@@ensure@dir#1{\ifcsundef{@ensure@dir}{#1}{\@ensure@dir{#1}}}
\def\@@ensure@maindir#1{\ifcsundef{@ensure@maindir}{#1}{\@ensure@maindir{#1}}}

%% Used by the language definitions files for right-to-left languages
\def\RequireBidi{%
  \str_case_e:nnF{\c_sys_engine_str}{
    {luatex}{\RequirePackage{luabidi}}
    {xetex}{\RequirePackage{bidi}}
  }
  {
    \xpg@warning{You’re running a TeX engine that is not LuaTeX or XeTeX.\MessageBreak
      That is almost guaranteed to cause problems.}
  }
}

% overwritten with correct package
\RequirePackage{filehook}
\cs_new:Nn{\polyglossia@ensure@direction:nn}{%
  \str_case_e:nnTF{#1}{%
       {LR}{#2}%
       {RL}{\xpg@error{right-to-left,~ but~ (lua)bidi~ package~ was~ not~ loaded!}}%
     }%
     {}%
     {\xpg@error{Unknown~ language~ direction~ #1 ~(base~ wrapper)}}%
}%
\cs_new_nopar:Nn{\polyglossia@setdirection:n}{%
  \str_case_e:nnTF{#1}{%
       {LR}{\relax}%
       {RL}{\xpg@error{right-to-left,~ but~ (lua)bidi~ package~ was~ not~ loaded!}}%
     }%
     {}%
     {\xpg@error{Unknown~ language~ direction~ #1 ~(base~ wrapper)}}%
}
\AtEndOfPackageFile*{bidi}{%
  \ExplSyntaxOn%
  \cs_gset:Nn{\polyglossia@ensure@direction:nn}{%
    \str_case_e:nnF{#1}{%
        {LR}{\@ensure@LTR{#2}}%
        {RL}{\@ensure@RTL{#2}}%
      }%
      {\xpg@error{Unknown~ language~ direction~ #1 ~(bidi~ wrapper)}%
    }%
  }
  \cs_gset_nopar:Nn{\polyglossia@setdirection:n}{%
    \str_case_e:nnTF{#1}{%
        {LR}{\setLR}%
        {RL}{\setRL}%
      }%
      {}%
      {\xpg@error{Unknown~ language~ direction~ #1 ~(bidi~ wrapper)}}%
  }%
  \ExplSyntaxOff%
}
\AtEndOfPackageFile*{luabidi}{%
  \ExplSyntaxOn%
  \cs_gset:Nn{\polyglossia@ensure@direction:nn}{%
    \str_case_e:nnTF{#1}{%
        {LR}{\@ensure@LTR{#2}}%
        {RL}{\@ensure@RTL{#2}}%
      }%
      {}%
      {\xpg@error{Unknown~ language~ direction~ #1 ~(luabidi~ wrapper)}}%
  }%
  \cs_gset_nopar:Nn{\polyglossia@setdirection:n}{%
    \str_case_e:nnTF{#1}{%
        {LR}{\setLR}%
        {RL}{\setRL}%
      }
      {}%
      {\xpg@error{Unknown~ language~ direction~ #1 ~(luabidi~ wrapper)}}%
  }%
  \ExplSyntaxOff%
}

%% compatibility with babel
\let\addto\gappto% gappto is defined in etoolbox

%% NEW EXPERIMENTAL SETUP INTERFACE FOR GLOSS FILES
%% options currently available:
%% language : the name of the language (as understood by fontspec)
%% hyphennames : the different hyphenation patterns to try (comma separated list)
%%%   TODO: if pattern is prefixed by !, then it should be loaded as a fallback, with \xpg@nopatterns@fallback - i.e. with a warning: e.g. sanskrit for hindi, or catalan for asturian. – Also for languages with variants!  (English and German, etc.)
%% script : the name of the script (as understood by fontspec) – default is Latin
%% scripttag : the OpenType tag for the script
%% langtag : the OpenType tag for the language
%% hyphenmins : the hyphenmins for this language (comma-sep list of two integers)
%% frenchspacing : boolean
%% indentfirst : boolean
%% fontsetup : boolean
%% TODO: nouppercase : boolean (for scripts like Arabic, Devanagari, etc which have no concept of uppercase/lowercase)
%% TODO: localalph = {<alph_csname>,<Alph_csname>}
%% TODO: localnumber = <csname>
%%       or even better localdigits = {0123456789} for fully automatic setup

\newif\if@xpg@language@really@defined@
\newcommand*\PolyglossiaSetup[2]{%
  \polyglossia@keys_define_lang:n{#1}%
  \keys_set:nn { polyglossia / #1 } { #2 }%
  %define booleans etoolbox style and set defaults
  %% TODO ? \providetoggle{#1@setup@done}%
  % we initialize these so that we can use \gappto below
  \csgdef{init@extras@#1}{}%
  \csgdef{init@noextras@#1}{}% we don't use this yet: remove?
  % here we do the fontsetup:
  \polyglossia@lang@autosetupfont:n{#1}
  %% TODO? \toggletrue{#1@setup@done}%
  % reinit \do
  \def\do##1{\setotherlanguage{##1}}%
}

% this an ugly command that will be drop in the future, it serve to document that
% using this we loose tracking and thus are not immune to bug #205 #208
\def\polyglossia@buggykeyssetlanguage#1#2 {
  \ExplSyntaxOn
  \keys_set:nn { polyglossia / #1 } { #2 }
  \ExplSyntaxOff
}


% setup hyphennames from a str list of hyphen
\cs_new:Nn \polyglossia@setup@hyphenames:nn {
  \clist_set:Nn{\l_tmpa_clist}{#2}
  % for each hyphen except for #1 aka language in the set
  \clist_map_inline:Nn \l_tmpa_clist {
    % check if language hyphenname is defined
    \polyglossia@check@ifdefined:NF{#1}{
      % if false check if current hypenname is egal of language hyphenname
      \str_if_eq:nnF{#1}{#2}{
        {
          % if language is different of hypenname then test if hypennation is defined
          \xpg@ifdefined{#2}{
            % test if language hyphennnation is nohyphenation
            \cs_if_eq:cNF{l@#1}{\l@nohyphenation}{
              % if false define language to hyphennation and load
              \cs_gset_eq:cc{l@#1}{l#2}
              \xpg@set@language@luatex@iv{#2}
            }
          }
          % else define hyphenation to nohypenation
          {
            \cs_gset_eq:cc{l@#2}{l@nohyphenation}
          }%
        }
      }%
    }
  }
  % if l@#1 does not yet exist,
  % we assign it to nohyphenation
  % we do this here in case the hyphennames key was omitted
  \xpg@ifdefined{#1}{}%
  {
    \xpg@nopatterns{#1}
    \expandafter\adddialect\csname l@#1\endcsname\l@nohyphenation\relax
  }%
  \csdef{#1@language}{%
    \ifbool{xpg@hyphenation@disabled}{%
      \xdef\xpg@lastlanguage{\the\csname l@#1\endcsname}%
    }{%
      \ifluatex%
      \xpg@set@language@luatex@iv{#1}%
      \fi%
      \language=\csname l@#1\endcsname%
    }%
  }%
  \prop_gput:Nnn{\polyglossia@langsetup}{#1/hyphennames}{#2}
}

\prop_new:N \polyglossia@langsetup

\cs_new_protected:Npn \polyglossia@keys_define_lang:n #1 {
  \keys_define:nn {polyglossia}{
    % the script font
    #1 / script
       .code:n = {
          \prop_gput:Nnn{\polyglossia@langsetup}{#1/script}{##1}
          \prop_gput:Nnx{\polyglossia@langsetup}{#1/lcscript}
               {\tl_if_empty:nF{##1}{\str_lower_case:n##1}}
    },
    #1 / script
       .value_required:n = true,
    #1 / script
       .initial:n = latin,
    % the opentype script tag
    #1 / scripttag
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/scripttag}{##1}},
    #1 / scripttag
       .default:n = {},
    #1 / scripttag
      .initial:n = {},
    % the language full name
    #1 / language
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/language}{##1}},
    #1 / language
       .value_required:n = true,
    #1 / language
        .initial:x = {\str_upper_case:n#1},
    % the language tag
    #1 / langtag
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/langtag}{##1}},
    #1 / langtag
       .value_required:n = true,
    #1 / langtag
       .initial:n = {},
    % hyphennames
    #1 / hyphennames
    .code:n = {
      \polyglossia@setup@hyphenames:nn{#1}{##1}
    },
    #1 / hyphennames
       .value_required:n = true,
    #1 / hyphennames
      .initial:x = {\c_empty_clist},
    % direction
    #1 / direction
    .  code:n = {
           \str_case_e:nnTF{##1}{
             {LR}{}
             {RL}{\RequireBidi}
           }
           {\prop_gput:Nnn{\polyglossia@langsetup}{#1/direction}{##1}}
           {\xpg@error{Unknown~ direction~ "##1"~ for~ language~ "#1"}}
       },
    #1 / direction
      .value_required:n = true,
    #1 / direction
      .initial:n = {LR},
    % minimal left and right hyphenation minima using
    #1 / hyphenmins
    .code:n = {
      % check syntax
      \clist_set:Nn{\l_tmpa_clist}{##1}
      \int_compare:nNnTF{\clist_count:N{\l_tmpa_clist}}{=}{2}
         {}
         {\xpg@error{hypenmins~should~be~a~list~of~two~entries~get~"##1"}}
      \int_set:Nn{\l_tmpa_int}{\clist_item:Nn{\l_tmpa_clist}{1}}
      \int_set:Nn{\l_tmpb_int}{\clist_item:Nn{\l_tmpa_clist}{2}}
      % set prop
      \prop_gput:Nnn{\polyglossia@langsetup}{#1/hypenmins}{##1}
      % create hyphenmins for language (will be overwritten later)
      \setlocalhyphenmins{#1}{\l_tmpa_int}{\l_tmpb_int}
    },
    #1 / hyphenmins
      .value_required:n = true,
    #1 / hyphenmins
     .initial:n = {2,3},
    % frenchspacing
    #1 / frenchspacing
    .code:n = {
        \str_case_e:nnTF{##1}{
            {true}{}
            {false}{}
          }
          {}
          {\xpg@error{frenchspacing~should~be~true~or~false. Is~ "##1"~ for~ language~ "#1"}}
        \prop_gput:Nnn{\polyglossia@langsetup}{#1/frenchspacing}{##1}
    },
    #1 / frenchspacing
      .default:n = true,
    #1 / frenchspacing
      .initial:n = false,
    % indent first line
    #1 / indentfirst
    .code:n = {
      \str_case_e:nnTF{##1}{
            {true}{}
            {false}{}
          }
          {}
          {\xpg@error{indentfirst~should~be~true~or~false. Is~ "##1"~ for~ language "#1"}}
      \prop_gput:Nnn{\polyglossia@langsetup}{#1/indentfirst}{##1}
    },
    #1 / indentfirst
      .default:n = true,
    #1 / indentfirst
      .initial:n = false,
    % fontsetup
    #1 / fontsetup
    .code:n = {
       \str_case_e:nnTF{##1}{
            {true}{}
            {false}{}
          }
          {}
          {\xpg@error{fontsetup~should~be~true~or~false. Is "##1"~ for~ language~ "#1"}}
       \prop_gput:Nnn{\polyglossia@langsetup}{#1/fontsetup}{##1}
    },
    #1 / fontsetup
      .default:n = true,
    #1 / fontsetup
      .initial:n = false,
    }
}

\cs_new_nopar:Nn{\polyglossia@lang@frenchspacing:n}{
  \prop_get:NnNTF \polyglossia@langsetup {#1/frenchspacing} \l_tmpa_tl
      {
        \str_case_e:nnF{\l_tmpa_tl}{
          {true}{\frenchspacing}
          {false}{\nonfrenchspacing}
        }
        {\xpg@error{frenchspacing~should~be~true~or~false. Is~"\l_tmpa_ttl"~ for~ language~ "#1"}}
      }
      {
        \xpg@error{Could~ not~ retrieve~ key~ frenchspacing~ for~ language~ "#1"}
        \prop_show:N{\polyglossia@langsetup}
      }
}

\cs_new_nopar:Nn{\polyglossia@lang@indentfirst:n}{
  \prop_get:NnNTF \polyglossia@langsetup {#1/indentfirst} \l_tmpa_tl
      {
        \str_case_e:nnF{\l_tmpa_tl}{
          {true}{\french@indent}
          {false}{\nofrench@indent}
        }
        {\xpg@error{indentfirst~should~be~true~or~false. Is~"\l_tmpa_ttl"~ for~ language~ "#1"}}
      }
      {
        \xpg@error{Could~ not~ retrieve~ key~ indentfirst~ for~ language~ "#1"}
        \prop_show:N{\polyglossia@langsetup}
      }
}

\cs_new:Nn{\polyglossia@lang@ensuredirection:nn}{
  \prop_get:NnNTF \polyglossia@langsetup {#1/direction} \l_tmpa_tl
      {
        \polyglossia@ensure@direction:nn{\l_tmpa_tl}{#2}
      }
      {
        \xpg@error{Could~ not~ retrieve~ key~ direction~ for~ language~ "#1"}
        \prop_show:N{\polyglossia@langsetup}
      }
}

\cs_new:Nn{\polyglossia@lang@setdirection:n}{
  \prop_get:NnNTF \polyglossia@langsetup {#1/direction} \l_tmpa_tl
      {
        \polyglossia@setdirection:n{\l_tmpa_tl}
      }
      {
        \xpg@error{Could~ not~ retrieve~ key~ direction~ for~ language~ "#1"}
        \prop_show:N{\polyglossia@langsetup}
      }
}

\AtEndDocument{\prop_log:N{\polyglossia@langsetup}}
\def\xpg@lastlanguage{0}%

\providebool{xpg@hyphenation@disabled}%
\boolfalse{xpg@hyphenation@disabled}

\def\xpg@disablehyphenation{%
  \ifbool{xpg@hyphenation@disabled}{}{%
    \booltrue{xpg@hyphenation@disabled}%
    \xdef\xpg@lastlanguage{\the\language}%
    \xpg@set@language@luatex@iv{nohyphenation}
    \language=\l@nohyphenation%
    \ifluatex %
      \directlua{polyglossia.disable_hyphenation()}%
    \fi %
  }%
}

\def\xpg@enablehyphenation{%
  \ifbool{xpg@hyphenation@disabled}{%
    \boolfalse{xpg@hyphenation@disabled}%
    \language=\csname xpg@lastlanguage\endcsname%
    \ifluatex %
      \directlua{polyglossia.enable_hyphenation()}%
    \fi %
  }{}%
}

\let\disablehyphenation\xpg@disablehyphenation
\let\enablehyphenation\xpg@enablehyphenation

%\def\xpg@fontsetup#1{\xpg@csifdef@warn{xpg@fontsetup@#1}}
%\def\xpg@fontsetup@none#1{\csgdef{#1@font}{\ifcsdef{#1font}{\csname #1font\endcsname}{}}} %<-- simplistic
%\def\xpg@fontsetup@custom#1{\csuse{#1@font}}

\cs_new:Nn \polyglossia@lang@autosetupfont:n {
  \str_if_eq:eeTF{\prop_item:Nn{\polyglossia@langsetup}{#1/fontsetup}}{true}
  {
    \str_if_eq:eeTF{\prop_item:Nn{\polyglossia@langsetup}{#1/script}}{latin}%
         {\xpg@fontsetup@latin{#1}}
         {\xpg@fontsetup@nonlatin{#1}}
  }
  {
    \xpg@info{Skipping~ automatic~ font~ setup~ for~ language~ #1}
  }
}


% add fontfeature Language=#2 to langtag #1
% do nothing if #1 or #2 is empty
\cs_new:Nn \polyglossia@addfontfeature@language:nn {
  \bool_if:nTF{\tl_if_empty_p:n{#1} || \tl_if_empty_p:n{#2}}
  {
    % maybe an error ?
    \xpg@warning{Asking~ to~ add~ empty~ feature~to~ latin~ font~
      (Language="#2"~ to~ langtag~ "#1")}
  }
  {
    \str_if_eq:nnTF{#2}{Turkish}{
      \fontspec_if_language:nTF {TRK}%
      {
        \addfontfeature{Language=Turkish}
      }
      {
        \fontspec_if_language:nTF {TUR}%
        {
          \addfontfeature{Language=Turkish}
        }{}
      }
    }{
      \fontspec_if_language:nTF{#1}
      {
        \addfontfeature{Language=#2}
      }
      {}
    }
  }
}
\cs_generate_variant:Nn  \polyglossia@addfontfeature@language:nn { on , no, oo , Vn, nV, VV , xn, nx, xx}

% add fontfeature Script=#2 to scripttag #1
% do nothing if #1 or #2 is empty
\cs_new:Nn \polyglossia@addfontfeature@script:nn {
  \bool_if:nTF{\tl_if_empty_p:n{#1} || \tl_if_empty_p:n{#2}}
  {
    % maybe an error ?
    \xpg@warning{Asking~ to~ add~ empty~ feature~to~ latin~ font
                 (Script="#2"~ to~ scriptag~ "#1")}
  }
  {
    \fontspec_if_script:nTF{#1}
       {\addfontfeature{Script=#2}}
       {\xpg@error{
          The~ current~ latin ~ font~ does~ not~ contain~ the~"#2"~ script!\MessageBreak
          Please~ define~string\~\tl_if_empty:nF{#2}{\str_lower_case:n#2}font~
          with~ \string\ newfontfamily command
          }
        }
  }
}
\cs_generate_variant:Nn  \polyglossia@addfontfeature@script:nn { on , no, oo , Vn, nV, VV , xn, nx, xx}

\def\xpg@fontsetup@latin#1{%
  \begingroup
  \csgdef{#1@font@rm}{%
    \cs_if_exist_use:cF{#1font}{
      \rmfamilylatin
      \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
    }
  }
  \csgdef{#1@font@sf}{%
    \cs_if_exist_use:cF{#1fontsf}{
      \sffamillylatin
      \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
    }%
  }%
  \csgdef{#1@font@tt}{%
    \cs_if_exist_use:cF{#1fonttt}{
      \ttfamillylatin
      \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
    }%
  }%
  \endgroup
}

\def\xpg@fontsetup@nonlatin#1{%
  \begingroup
  \csgdef{#1@font@rm}{%
    \cs_if_exist_use:cF{#1font}
      {
       \str_if_eq:nnTF{\prop_item:Nn{\polyglossia@langsetup}{#1/script}}{\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
        {\rmfamilylatin}%
        {\cs_if_exist_use:cTF{\prop_item:Nn{\polyglossia@langsetup}{#1/lcscript} font}
          {
            \polyglossia@addfontfeature@script:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/scripttag}}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/script}}
           }
           {
             \rmfamilylatin
           }
       }
       \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
      }}%
  \csgdef{#1@font@sf}{%
    \cs_if_exist_use:cF{#1fontsf}%
      {
       \str_if_eq:nnTF{\prop_item:Nn{\polyglossia@langsetup}{#1/script}}{\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
        {\sffamilylatin}%
        {\cs_if_exist_use:cTF{\prop_item:Nn{\polyglossia@langsetup}{#1/lcscript} fontsf}
          {
            \polyglossia@addfontfeature@script:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/scripttag}}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/script}}
           }
           {
             \sffamilylatin
           }
       }
       \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
      }}%
  \csgdef{#1@font@tt}{%
    \cs_if_exist_use:cF{#1fonttt}%
      {
       \str_if_eq:nnTF{\prop_item:Nn{\polyglossia@langsetup}{#1/script}}{\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
       {\ttfamilylatin}%
       {\cs_if_exist_use:cTF{\prop_item:Nn{\polyglossia@langsetup}{#1/lcscript} fonttt}
           {
            \polyglossia@addfontfeature@script:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/scripttag}}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/script}}
           }
           {
             \ttfamilylatin
           }
       }
       \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
      }}%
  \endgroup
}

%%% END OF PolyglossiaSetup

%% ensure localization of \markright and \markboth commands
%%% THIS IS NOW DISABLED BY DEFAULT
\newcommand{\local@marks}[1]{}
\def\enable@local@marks{
      \xpg@info{Option:~ localmarks}%
      \def\local@marks##1{%
         \def\markboth####1####2{%
            \begingroup
               \let\label\relax \let\index\relax \let\glossary\relax
               \unrestored@protected@xdef\@themark
         {{\foreignlanguage{##1}{%
            \protect\@@ensure@maindir{####1}}}%
          {\foreignlanguage{##1}{%
      \protect\@@ensure@maindir{####2}}}}%
               \@temptokena \expandafter{\@themark}%
               \mark{\the\@temptokena}%
            \endgroup
            \if@nobreak\ifvmode\nobreak\fi\fi}%
            \def\markright####1{%
               \begingroup
                  \let\label\relax \let\index\relax \let\glossary\relax
                  \expandafter\@markright\@themark
      {\foreignlanguage{##1}{\protect\@@ensure@maindir{####1}}}%
                  \@temptokena \expandafter{\@themark}%
                  \mark{\the\@temptokena}%
               \endgroup
               \if@nobreak\ifvmode\nobreak\fi\fi}%
            \def\@markright####1####2####3{\@temptokena{\protect\@@ensure@maindir{####1}}%
               \unrestored@protected@xdef\@themark{{\the\@temptokena}%
               {\protect\@@ensure@maindir{####3}}}}}%
}


% Easy way out – Arthur, 2012-08-01
\ifcsdef{newXeTeXintercharclass}{%
% to reset the intercharclass of a character to "normal"
\newXeTeXintercharclass\xpg@normalclass %TODO
}{}

%% when no patterns are available, we use \l@nohyphenation, assigned to 255
%%  (suggestion by Enrico Gregorio)
\@ifundefined{l@nohyphenation}{\chardef\l@nohyphenation=255 }{}

%we call this macro when a gloss file is not found for a given language
\def\xpg@nogloss#1{%
   \xpg@warning{File~ gloss-#1.ldf~ does~ not~ exist!\MessageBreak
   I~ will~ nevertheless~ try~ to~ use~ hyphenation~ patterns~ for~ #1.}%
  \PolyglossiaSetup{#1}{hyphenmins,hyphennames={#1},fontsetup=true}%
  % the above amounts to:
  %\ifcsundef{l@#1}%
  %  {\expandafter\adddialect\csname l@#1\endcsname\l@nohyphenation\relax}%
  %  {\setlocalhyphenmins{#1}{2}{3}}%
  %\csdef{#1@language}{\language=\csname l@#1\endcsname}%
}

\newcommand{\xpg@input}[1]{%
  \chardef\xpg@atcatcode\catcode`\@
  \makeatletter
  \input{#1}\catcode`\@=\xpg@atcatcode}

\newcommand{\setdefaultlanguage}[2][]{%
  \edef\xpg@loaded{#2\ifx\xpg@loaded\@empty\else,\xpg@loaded\fi}%
   \IfFileExists{gloss-#2.ldf}%
   {\ifcsundef{#2@loaded}%
     {\xpg@input{gloss-#2.ldf}%
     \xpg@info{Default~ language~ is~ #2}%
     \def\languagename{#2}%
     \ifluatex %
       \directlua{polyglossia.set_default_language('\luatexluaescapestring{\string#2}')}%
     \fi %
      % This is needed because \arabic is a built-in LaTeX command:
      % so now we have \begin{Arabic}... instead of \begin{arabic}...
      \ifstrequal{#2}{arabic}%
      {\newenvironment{Arabic}[1][]{\begin{otherlanguage}[####1]{arabic}}%
        {\end{otherlanguage}}}%
      {\newenvironment{#2}[1][]{\begin{otherlanguage}[####1]{#2}}%
        {\end{otherlanguage}}}%
      \expandafter\newcommand\csname text#2\endcsname[2][]{%
        \polyglossia@lang@ensuredirection:nn{#2}
                {\foreignlanguage[####1]{#2}{####2}}
      }%
      \csletcs{local#2}{text#2}%
      \csgdef{#2@loaded}{}%
      \gdef\xpg@main@language{#2}%
      }%
      {\xpg@warning{gloss-#2.ldf~ is~ already~ loaded!}}%:
      %% The following settings are for the default language and script
      % this tells bidi.sty that the document is RTL
      \str_if_eq:eeTF{\prop_item:Nn{\polyglossia@langsetup}{#2/direction}}{RL}{\@RTLmaintrue}{}%
      \AtBeginDocument{%
      \selectlanguage[#1]{#2}%
      \selectbackgroundlanguage{#2}}%
   }%
   %ELSE
   {\xpg@nogloss{#2}}%
}

\let\setmainlanguage=\setdefaultlanguage

\newcommand{\resetdefaultlanguage}[2][]{%
    \ifcsundef{#2@loaded}{%
     \xpg@error{gloss-#2.ldf~ is~ not~ loaded!}}%
    {\csuse{no\xpg@main@language @globalnumbers}% disable globalnumbers of previously defined default language
    \csuse{noextras@\xpg@main@language}%
    \csuse{init@noextras@\xpg@main@language}%
    \def\languagename{#2}%
    \str_if_eq:eeTF{\prop_item:Nn{\polyglossia@langsetup}{#2/direction}}{RL}{\@rlmaintrue\@rl@footnotetrue}{}%
    \selectlanguage[#1]{#2}%
    \selectbackgroundlanguage{#2}}}

\expandafter\ifx\familydefault\sfdefault
  \def\familytype{sf}
\else\expandafter\ifx\familydefault\ttdefault
  \def\familytype{tt}
\else
  \def\familytype{rm}
\fi\fi
% This robustifies the redefinitions of \<xx>family (suggestion by Enrico Gregorio)
% e.g. to prevent expansion of the \familytype redefinition in auxiliary files
\csgappto{rmfamily~}{\def\familytype{rm}}
\csgappto{sffamily~}{\def\familytype{sf}}
\csgappto{ttfamily~}{\def\familytype{tt}}
% This saves the normalfont for the latin script since we may change normalfont in other scripts
\let\normalfontlatin=\normalfont%
\let\rmfamilylatin=\rmfamily%
\let\sffamilylatin=\sffamily%
\let\ttfamilylatin=\ttfamily%

\def\resetfontlatin{%
   \let\rmfamily=\rmfamilylatin%
   \let\sffamily=\sffamilylatin%
   \let\ttfamily=\ttfamilylatin%
   \let\normalfont=\normalfontlatin}

\def\selectfontfamilylatin{%
  \def\tmp@tt{tt}\def\tmp@sf{sf}%
  \ifx\familytype\tmp@tt%
    \ttfamilylatin%
    \else\ifx\familytype\tmp@sf%
      \sffamilylatin%
      \else\rmfamilylatin\fi\fi}

\def\xpg@select@fontfamily#1{%
  \def\tmp@tt{tt}\def\tmp@sf{sf}%
  \ifx\familytype\tmp@tt
    \csuse@warn{#1@font@tt}%
  \else\ifx\familytype\tmp@sf
    \csuse@warn{#1@font@sf}%
      \else\csuse@warn{#1@font@rm}\fi\fi}

\def\xpg@set@normalfont#1{%
  \letcs{\rmfamily}{#1@font@rm}%
  \letcs{\sffamily}{#1@font@sf}%
  \letcs{\ttfamily}{#1@font@tt}%
  \gdef\normalfont{\protect\xpg@select@fontfamily{#1}}%
  \gdef\reset@font{\protect\normalfont}%
}

\let\@@fterindentfalse\@afterindentfalse
\def\french@indent{\let\@afterindentfalse\@afterindenttrue
                        \@afterindenttrue}
\def\nofrench@indent{\let\@afterindentfalse\@@fterindentfalse
                          \@afterindentfalse}
\newcommand{\selectbackgroundlanguage}[1]{%
  \str_if_eq:eeTF{\prop_item:Nn{\polyglossia@langsetup}{#1/script}}{latin}{}{\xpg@set@normalfont{#1}}%
  \csuse{#1@globalnumbers}%
}

\newcommand{\setotherlanguage}[2][]{%
  \edef\xpg@loaded{#2\ifx\xpg@loaded\@empty\else,\xpg@loaded\fi}%
   \IfFileExists{gloss-#2.ldf}%
   {\ifcsundef{#2@loaded}%
     {\xpg@input{gloss-#2.ldf}%
      \setkeys{#2}{#1}%
      \edef\@tmpa{arabic}%
      \edef\@tmpb{#2}%
      \ifx\@tmpb\@tmpa%
      \newenvironment{Arabic}[1][]{\begin{otherlanguage}[####1]{arabic}}%
         {\end{otherlanguage}}%
      \else
      \newenvironment{#2}[1][]{\begin{otherlanguage}[####1]{#2}}%
         {\end{otherlanguage}}%
      \fi
      \expandafter\newcommand\csname text#2\endcsname[2][]{%
        \polyglossia@lang@ensuredirection:nn{#2}%
              {\foreignlanguage[####1]{#2}{####2}}
      }%
     \csletcs{local#2}{text#2}%
     \csgdef{#2@loaded}{}%
     }%
     {\xpg@warning{gloss-#2.ldf~ is~ already~ loaded!}}%
   }%
   %ELSE
   {\xpg@nogloss{#2}}%
}

\newcommand\setotherlanguages[1]{%
  \def\do##1{\setotherlanguage{##1}}%
   \docsvlist{#1}}%

\def\common@language{% FIXME is this really needed???
  \ifbool{xpg@hyphenation@disabled}{%
    \xdef\xpg@lastlanguage{\z@}%
  }{%
    \language=\z@
  }%
  \lefthyphenmin=\tw@
  \righthyphenmin=\thr@@}

\def\noextrascurrent#1{\csuse{noextras@#1}}

\def\xpg@initial@setup{\ifcsundef{languagename}{}%
   {\noextrascurrent{\languagename}}%
   \common@language}

\AtBeginDocument{\xpg@initial@setup}

\providecommand{\foreignlanguage}{}

\renewcommand{\foreignlanguage}[3][]{%
   \ifcsundef{#2@loaded}%
     {\xpg@nogloss{#2}}%
     {{\select@@language{#2}%
      \setkeys{#2}{#1}%
      \use@localhyphenmins{#2}%
      \polyglossia@lang@frenchspacing:n{#2}
      \csuse{inlineextras@#2}%
      #3}%
     }%
}

% otherlanguage* is the environment equivalent of \foreignlanguage
\expandafter\providecommand\csname otherlanguage*\endcsname{}
\renewenvironment{otherlanguage*}[2][]{%
   \ifcsundef{#2@loaded}%
     {\xpg@nogloss{#2}}%
     {\select@@language{#2}%
      \setkeys{#2}{#1}%
      \use@localhyphenmins{#2}%
      \polyglossia@lang@frenchspacing:n{#2}
      \csuse{inlineextras@#2}\csuse{date#2}%
     }%
}{}

%Hook that other package authors can use
%(for instance biblatex):
\newcommand*{\xpg@hook@setlanguage}{}

\def\xpg@pop@language@i#1{%
         \xpg@set@language{#1}%
         \xpg@hook@setlanguage%
         \let\emp@langname\@undefined}%

\providecommand{\selectlanguage}{}
\renewcommand{\selectlanguage}[2][]{%
   \ifcsundef{#2@loaded}%
     {\xpg@nogloss{#2}}%
     {\expandafter\def\expandafter\xpg@pop@language@i\expandafter\languagename
      \aftergroup\xpg@pop@language%
      % If the optional argument sets a value for the key “variant”, copy it to xpg@langvariant
      \def\do##1{%
          \def\xpg@parsekeyvalue####1=####2\relax{%
              \def\@tmpa{####1}
              \def\@tmpb{variant}
              \ifx\@tmpa\@tmpb\setkeys{xpg@langvariant}{##1}\fi
          }%
          \xpg@parsekeyvalue##1=\relax
      }%
      \docsvlist{#1}
      \setkeys{#2}{#1}%
      \xpg@set@language{#2}%
     }%
}


% Save any variant in csv list of variants
\define@key{xpg@langvariant}{variant}{%
  \edef\xpg@vloaded{#1\ifx\xpg@vloaded\@empty\else,\xpg@vloaded\fi}}

\newcommand{\xpg@set@language}[1]{%
   \@select@language{#1}%
   \if@filesw%
      \protected@write\@auxout{}{\protect\@select@language{#1}}%
      \addtocontents{toc}{\protect\@select@language{#1}}%
      \addtocontents{lof}{\protect\@select@language{#1}}%
      \addtocontents{lot}{\protect\@select@language{#1}}%
   \fi
}

\def\xpg@set@language@luatex@iii#1#2{%
    % here we use lu@texhyphen@loaded@\the\language, the same as in babel
    \ifcsdef{bbl@hyphendata@#2}{}{%
        \global\@namedef{bbl@hyphendata@\the\language}{}%
        \directlua{polyglossia.select_language('\luatexluaescapestring{\string#1}', \the\csname l@#1\endcsname)}%
    }
}

\prg_set_conditional:Npnn \polyglossia@check@ifdefined:N #1 { p , T , F , TF }{
  \cs_if_exist:cTF{l@#1}{
    \cs_if_eq:cNTF{l@#1}{\l@nohyphenation}{\prg_return_false:}{\prg_return_true:}
  }{
    \prg_return_false:
  }
}

\newcommand\xpg@ifdefined[3]{%
    \ifluatex
        \xpg@set@language@luatex@iv{#1}%
    \fi
    \polyglossia@check@ifdefined:NTF{#1}{#2}{#3}
}%

\newcommand\xpg@set@language@luatex@iv[1]{%
    \ifluatex
        \polyglossia@check@ifdefined:NF{#1}{
            \expandafter\chardef\csname l@#1\endcsname=\directlua{tex.sprint(polyglossia.newloader('#1'))}%
        }
        \language\directlua{tex.sprint(polyglossia.newloader('#1'))}%
    \fi
}

\newcommand\xpg@set@language@luatex@ii[1]{%
   \ifluatex %
     \xpg@set@language@luatex@iii{#1}{\expandafter\the\csname l@#1\endcsname}
   \fi % 
}


\def\@select@language#1{
  % hook for compatibility with biblatex
  \select@language{#1}
  \ifluatex %
      \xpg@set@language@luatex@iii{#1}{\the\language}
   \fi %
   \xpg@initial@setup%
   \select@@language{#1}%
   \polyglossia@lang@setdirection:n{#1}
   \csuse{captions#1}%
   \local@marks{#1}%
   \csuse{init@extras@#1}%
   \polyglossia@lang@indentfirst:n{#1}
   \polyglossia@lang@frenchspacing:n{#1}
   \csuse{blockextras@#1}%
 }

% hook for compatibility with biblatex
\def\select@language#1{}

% Common code for `\select@language' and `\foreignlanguage'.
\newcommand{\select@@language}[1]{%
  \edef\languagename{#1}%
  \xpg@select@fontfamily{#1}%
  \csuse@warn{#1@language}%
  \csuse{date#1}%
  \csuse{#1@numbers}%
  \use@localhyphenmins{#1}%
}


\let\xpg@pop@language\relax

\provideenvironment{otherlanguage}{}{}

\renewenvironment{otherlanguage}[2][]
   {\selectlanguage[#1]{#2}}
   {}

\newcommand{\setlocalhyphenmins}[3]{%
   \xpg@ifdefined{#1}{%
      \expandafter\ifx\csname l@#1\endcsname\l@nohyphenation%
        \xpg@warning{\string\setlocalhyphenmin\space~ useless~ for~ unhyphenated~ language~ #1}%
      \else
      \providehyphenmins{#1}{#2#3}%
      \fi
   }{%
     \xpg@warning{\string\setlocalhyphenmin\space~ useless~ for~ unknown~ language~ #1}%
   }}%

\def\use@localhyphenmins#1{%
   \ifcsundef{#1hyphenmins}{}%
   {\expandafter\expandafter\expandafter\set@hyphenmins\csname #1hyphenmins\endcsname\relax}}


\AtEndPreamble{\@ifpackageloaded{bidi}{\providecommand*{\aemph}[1]{$\overline{\hboxR{#1}}$}}{}}% TODO Make that work for luabidi too.


% keys for main package
\keys_define:nn { polyglossia } {
  verbose
     .bool_set:N = \l_polyglossia_verbose_bool,
  verbose
     .default:n = true,
  % compatibility
  quiet
     .meta:n =  { verbose = false },

  localmarks
     .bool_set:N = \l_polyglossia_localmarks_bool,
  localmarks
     .default:n = false,
  % compatibility
  nolocalmarks
     .meta:n = { localmark = false },
   
  babelshorthands
     .bool_set:N = \l_polyglossia_babelshorthands_bool,
  babelshorthands
     .default:n = true,
}

\keys_set:nn { polyglossia } {
  localmarks = false,
  verbose = true,
  babelshorthands = false,
}


\ProcessKeysOptions{polyglossia}

\bool_if:nTF \l_polyglossia_verbose_bool {} {
   \gdef\@latex@info#1{\relax}% no latex info
   \gdef\@font@info#1{\relax}% no latex font info
   \gdef\@font@warning#1{\relax}% no latex font warnings
   \gdef\zf@PackageInfo#1{\relax}% no fontspec info
   \gdef\xpg@info#1{\relax}% no polyglossia info
}

\bool_if:nTF \l_polyglossia_localmarks_bool {} {
  \enable@local@marks{}
}{}

% compatibility
\newif\ifsystem@babelshorthands
\bool_if:nTF \l_polyglossia_babelshorthands_bool {
  \system@babelshorthandstrue
}{
  \system@babelshorthandsfalse
}


%
% FIXME these should also be loaded \AtEndOfPackage !!!
\def\xpg@option#1#2{%
  \ifcsundef{xpg@main@language}{\setdefaultlanguage}{\setotherlanguage}%
    [#1]{#2}}
\ExplSyntaxOff

\endinput
